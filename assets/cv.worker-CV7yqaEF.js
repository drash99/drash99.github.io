(function(){"use strict";let e=null;const l={REAL_WIDTH_MM:180,REAL_HEIGHT_MM:250,GRAY_PATCH_Y_MM:45,GRAY_PATCH_XS_MM:Array.from({length:11},(n,r)=>55+r*9.5),EXPECTED_LEVELS:Array.from({length:11},(n,r)=>Math.round(255-r*235/10)),CMYK_PATCH_Y_MM:30,CMYK_PATCH_XS_MM:[106,120,134,148],STAGE_CENTER_X_MM:90,STAGE_CENTER_Y_MM:115,STAGE_SIZE_MM:100,STAGE_MARGIN_MM:10,SCALE:18};async function _e(n,r=8e3){const s=()=>{var t;return(n==null?void 0:n.Mat)!=null&&typeof n.Mat=="function"||((t=n==null?void 0:n.cv)==null?void 0:t.Mat)!=null&&typeof n.cv.Mat=="function"};if(s())return;let o=!1;if(await new Promise((t,a)=>{const _=Date.now();try{n.onRuntimeInitialized=()=>{o=!0,t()}}catch{}const h=setInterval(()=>{if(s()){clearInterval(h),o||t();return}Date.now()-_>r&&(clearInterval(h),a(new Error("OpenCV init timeout: cv.Mat not available")))},25)}),!s())throw new Error("OpenCV loaded but Mat constructor missing (wrong artifact or init not complete)")}self.onmessage=async n=>{var s;const r=n.data;if(r.type==="INIT")try{const o=((s=r.payload)==null?void 0:s.opencvUrl)??new URL("/opencv.js",self.location.origin).href,t=await fetch(o);if(!t.ok)throw new Error(`opencv.js fetch failed: ${t.status} ${t.statusText}`);const a=await t.text(),_="__opencv_root__",h=a.replace(/\}\s*\}\s*\(\s*this\s*,/,"}}("+_+",");new Function(_,h)(self);const i=self.cv;let u;if(typeof i=="function")u=await i({});else if(i&&typeof i.then=="function")u=await i;else if(i&&typeof i=="object")u=i;else{postMessage({type:"ERROR",payload:"OpenCV did not expose cv (factory/promise/object). Is public/opencv.js the full build?"});return}await _e(u);const P=D=>D!=null&&typeof D.Mat=="function",x=P(u)?u:u==null?void 0:u.cv;if(!x||!P(x)){postMessage({type:"ERROR",payload:"OpenCV Module has no Mat constructor. Build may be incomplete or wrong file."});return}const A=Object.create(null);Object.assign(A,u),Object.assign(A,x),e=A,self.cv=A,postMessage({type:"CV_READY"})}catch(o){console.error("Failed to load OpenCV",o);const t=o instanceof Error?o.message:String(o);postMessage({type:"ERROR",payload:t||"Failed to load OpenCV. Ensure opencv.js is in public/."})}else if(r.type==="PROCESS_IMAGE"){if(console.log("[CV] PROCESS_IMAGE received"),!e||typeof e.Mat!="function"){postMessage({type:"ERROR",payload:"OpenCV not ready: cv.Mat missing"});return}try{const o=ye(r.payload);postMessage({type:"ANALYSIS_COMPLETE",payload:o})}catch(o){console.error("CV Processing Error:",o),postMessage({type:"ERROR",payload:o.message})}}};function Ee(n){const r=new e.Mat(n.height,n.width,e.CV_8UC4);return r.data.set(n.data),r}function ce(n,r,s,o){const t=new e.Mat(n,r,s);return t.data32F.set(new Float32Array(o)),t}function le(n,r,s){const o=new e.Mat(n,r,s);return o.setTo(new e.Scalar(0)),o}function Ae(n,r){const s=new e.Mat(n,r,e.CV_8U);return s.setTo(new e.Scalar(1)),s}function ye(n){const{imageData:r,rulerLengthMm:s,mode:o}=n,t=s/100;console.log("[CV] processImage start",{mode:o,width:r.width,height:r.height}),postMessage({type:"DEBUG",payload:{matType:typeof(e==null?void 0:e.Mat),cv8uc4:e==null?void 0:e.CV_8UC4,matFromImageDataType:typeof(e==null?void 0:e.matFromImageData)}});let a=Ee(r);const _=2048;if(Math.max(a.rows,a.cols)>_){const c=_/Math.max(a.rows,a.cols),M=new e.Size(Math.round(a.cols*c),Math.round(a.rows*c)),d=new e.Mat;e.resize(a,d,M,0,0,e.INTER_AREA),a.delete(),a=d,console.log("[CV] Resized input to",a.cols,"x",a.rows)}let h=new e.Mat;e.cvtColor(a,h,e.COLOR_RGBA2GRAY),console.log("[CV] src/gray created");let i,u=!1;try{const c=e.aruco&&typeof e.aruco.getPredefinedDictionary=="function"?e.aruco.getPredefinedDictionary.bind(e.aruco):typeof e.getPredefinedDictionary=="function"?e.getPredefinedDictionary.bind(e):null,M=e.aruco&&e.aruco.DICT_4X4_50!=null?e.aruco.DICT_4X4_50:e.DICT_4X4_50,d=e.aruco&&e.aruco.DetectorParameters||e.aruco_DetectorParameters,p=e.aruco&&e.aruco.RefineParameters||e.aruco_RefineParameters,E=e.aruco&&e.aruco.CORNER_REFINE_SUBPIX!=null?e.aruco.CORNER_REFINE_SUBPIX:e.CORNER_REFINE_SUBPIX,V=e.aruco&&e.aruco.ArucoDetector||e.aruco_ArucoDetector||e.ArucoDetector,z=!!(c&&M!=null&&(d||V));if(z||console.log("[CV] ArUco not available",{hasGetPredefinedDictionary:!!c,hasDictEnum:M!=null,hasDetectorParams:!!d,hasArucoDetector:!!V,hasCvAruco:!!e.aruco},"→ using fallback"),z&&c){console.log("[CV] ArUco detection start");const U=c(M),m=d?new d:null,f=p?new p(10,3,!0):null;m&&E!=null&&typeof m.cornerRefinementMethod<"u"&&(m.cornerRefinementMethod=E);const C=new e.MatVector,N=new e.Mat,K=new e.MatVector;if(V&&m!==null&&f!==null)new V(U,m,f).detectMarkers(h,C,N,K);else if(e.aruco&&typeof e.aruco.detectMarkers=="function")e.aruco.detectMarkers(h,U,C,N,m,K);else throw new Error("No detectMarkers API available");const W=K.size(),Z=[];for(let S=0;S<N.rows;S++)Z.push(N.intPtr(S,0)[0]);if(console.log("[CV] ArUco detectMarkers result:",{numMarkers:C.size(),numIds:N.rows,numRejected:W,detectedIds:Z.length?Z:void 0}),N.rows>=4){const S={};for(let y=0;y<N.rows;y++){const v=N.intPtr(y,0)[0];v>=0&&v<=3&&(S[v]=C.get(y))}const ee=Object.keys(S).map(Number).sort((y,v)=>y-v);if(console.log("[CV] ArUco markers with id 0–3:",{foundIds:ee,count:ee.length}),Object.keys(S).length>=4){const y=(Ce,we)=>[Ce.data32F[we*2],Ce.data32F[we*2+1]],v=y(S[0],0),te=y(S[1],1),oe=y(S[2],2),ne=y(S[3],3),Me=[v[0],te[0],oe[0],ne[0]],fe=[v[1],te[1],oe[1],ne[1]],Te=Math.min(...Me),Ve=Math.max(...Me),Le=Math.min(...fe),be=Math.max(...fe),ae=Ve-Te,re=be-Le,se=ae/(re||1),me=180/250,he=.15,ge=ae>=r.width*he&&re>=r.height*he,pe=se>=me*.6&&se<=me*1.6;ge&&pe?(i=ce(4,1,e.CV_32FC2,[...v,...te,...oe,...ne]),u=!0,console.log("[CV] ArUco: quad accepted",{boxW:ae,boxH:re,aspect:se,corners:{tl:v,tr:te,br:oe,bl:ne}})):console.log("[CV] ArUco: quad rejected (size or aspect)",{boxW:ae,boxH:re,aspect:se,validSize:ge,validAspect:pe}),C.delete(),N.delete(),K.delete(),m&&m.delete(),f&&typeof f.delete=="function"&&f.delete()}else console.log("[CV] ArUco: need ids 0,1,2,3, got",ee,"→ using fallback"),C.delete(),N.delete(),K.delete(),m&&m.delete(),f&&typeof f.delete=="function"&&f.delete()}else console.log("[CV] ArUco: fewer than 4 markers detected → using fallback")}}catch(c){console.warn("[CV] ArUco detection failed, using fallback:",c)}if(u||console.log("[CV] Fallback: square marker detection"),!u){let c=new e.Mat;e.adaptiveThreshold(h,c,255,e.ADAPTIVE_THRESH_GAUSSIAN_C,e.THRESH_BINARY_INV,11,2);let M=Ae(5,5);e.morphologyEx(c,c,e.MORPH_CLOSE,M),M.delete();let d=new e.MatVector,p=new e.Mat;e.findContours(c,d,p,e.RETR_TREE,e.CHAIN_APPROX_SIMPLE);let E=[];const V=r.width*r.height*5e-4;for(let f=0;f<d.size();++f){let C=d.get(f);if(e.contourArea(C)<V)continue;let K=e.arcLength(C,!0),W=new e.Mat;if(e.approxPolyDP(C,W,.04*K,!0),W.rows===4&&e.isContourConvex(W)){let Z=e.boundingRect(W),S=Z.width/Z.height;if(S>=.8&&S<=1.2&&p.intPtr(0,f)[2]!==-1){let y=e.moments(C);E.push({x:y.m10/y.m00,y:y.m01/y.m00})}W.delete()}else W.delete()}if(E.length<4)throw a.delete(),h.delete(),c.delete(),d.delete(),p.delete(),new Error(`Found only ${E.length} markers. Need 4.`);E.sort((f,C)=>f.y-C.y);const z=E.slice(0,2).sort((f,C)=>f.x-C.x),U=E.slice(2,4).sort((f,C)=>f.x-C.x),m=[z[0],z[1],U[1],U[0]];i=ce(4,1,e.CV_32FC2,[m[0].x,m[0].y,m[1].x,m[1].y,m[2].x,m[2].y,m[3].x,m[3].y]),c.delete(),d.delete(),p.delete(),console.log("[CV] Fallback: markers found, srcPts set")}console.log("[CV] Perspective warp");const P=l.REAL_WIDTH_MM*l.SCALE,x=l.REAL_HEIGHT_MM*l.SCALE,A=ce(4,1,e.CV_32FC2,[0,0,P,0,P,x,0,x]),D=e.getPerspectiveTransform(i,A),R=new e.Mat;e.warpPerspective(a,R,D,new e.Size(P,x)),console.log("[CV] Warp done, color calibration (gray ramp)");const H=l.GRAY_PATCH_Y_MM*l.SCALE,L=Math.floor(1.5*l.SCALE),I=[];for(const c of l.GRAY_PATCH_XS_MM){const M=c*l.SCALE,d=R.roi(new e.Rect(M-L,H-L,L*2,L*2)),p=e.mean(d);I.push([p[0],p[1],p[2]]),d.delete()}const b={r:ie(I.map(c=>c[0]),l.EXPECTED_LEVELS),g:ie(I.map(c=>c[1]),l.EXPECTED_LEVELS),b:ie(I.map(c=>c[2]),l.EXPECTED_LEVELS)};console.log("[CV] LUTs built");let O={r:1,g:1,b:1};if(o==="bean"){console.log("[CV] Bean mode: CMYK WB");const c=l.CMYK_PATCH_Y_MM*l.SCALE,M=Math.floor(3*l.SCALE),d=[];for(const U of l.CMYK_PATCH_XS_MM){const m=U*l.SCALE,f=R.roi(new e.Rect(m-M,c-M,M*2,M*2)),C=e.mean(f);d.push([C[0],C[1],C[2]]),f.delete()}const p=(d[0][0]+d[1][0]+d[2][0])/3,E=(d[0][1]+d[1][1]+d[2][1])/3,V=(d[0][2]+d[1][2]+d[2][2])/3,z=128;O={r:p>0?z/p:1,g:E>0?z/E:1,b:V>0?z/V:1}}const B=l.STAGE_SIZE_MM/2-l.STAGE_MARGIN_MM,J=(l.STAGE_CENTER_X_MM-B)*l.SCALE,$=(l.STAGE_CENTER_Y_MM-B)*l.SCALE,G=B*2*l.SCALE,j=R.roi(new e.Rect(J,$,G,G));console.log("[CV] Stage ROI extracted, calling",o==="grind"?"analyzeGrind":"analyzeBeans");let w;o==="grind"?w=Re(j,b,t):w=Ie(j,b,O,t),j.delete(),ue(R,b);const T=new e.Scalar(0,255,0,255),Q=new e.Scalar(255,0,255,255);for(const c of l.GRAY_PATCH_XS_MM){const M=Math.round(c*l.SCALE),d=Math.round(l.GRAY_PATCH_Y_MM*l.SCALE);e.circle(R,new e.Point(M,d),L,T,2)}const q=Math.round(l.CMYK_PATCH_Y_MM*l.SCALE),k=Math.floor(3*l.SCALE);for(const c of l.CMYK_PATCH_XS_MM){const M=Math.round(c*l.SCALE);e.circle(R,new e.Point(M,q),k,Q,2)}const X=.25,g=Math.round(R.cols*X),F=Math.round(R.rows*X),Y=new e.Mat;return e.resize(R,Y,new e.Size(g,F),0,0,e.INTER_AREA),w.warpedImageData=de(Y),Y.delete(),w.lutCurves={r:Array.from(b.r),g:Array.from(b.g),b:Array.from(b.b)},console.log("[CV] Analysis done, cleanup"),a.delete(),h.delete(),i.delete(),A.delete(),D.delete(),R.delete(),w}function Re(n,r,s){console.log("[CV] analyzeGrind start");const o=n.clone();ue(o,r);const t=new e.Mat;e.cvtColor(o,t,e.COLOR_RGBA2GRAY);const a=new e.Mat;e.GaussianBlur(t,a,new e.Size(3,3),0);const _=new e.Mat;e.addWeighted(t,1.5,a,-.5,0,_);const h=new e.Mat;e.convertScaleAbs(_,h,2.5,-50);const i=new e.Mat;e.threshold(h,i,0,255,e.THRESH_BINARY_INV+e.THRESH_OTSU);const u=e.getStructuringElement(e.MORPH_ELLIPSE,new e.Size(3,3));e.morphologyEx(i,i,e.MORPH_CLOSE,u),u.delete();const P=le(i.rows,i.cols,e.CV_8UC1),x=Math.floor(Math.min(i.rows,i.cols)*.48);e.circle(P,new e.Point(i.cols/2,i.rows/2),x,new e.Scalar(255),-1),e.bitwise_and(i,i,i,P),console.log("[CV] analyzeGrind: findContours");const A=new e.MatVector,D=new e.Mat;e.findContours(i,A,D,e.RETR_EXTERNAL,e.CHAIN_APPROX_SIMPLE);const R=10,H=i.rows*i.cols*.2,L=l.SCALE/s,I=[],b=[new e.Scalar(0,255,0,255),new e.Scalar(0,0,255,255),new e.Scalar(255,0,0,255),new e.Scalar(0,255,255,255)],O=o.clone();for(let g=0;g<A.size();g++){const F=A.get(g),Y=e.contourArea(F);if(Y<R||Y>H||F.rows<5)continue;const c=e.fitEllipse(F),M=Math.max(c.size.width,c.size.height),d=Math.min(c.size.width,c.size.height),p=M/L,E=d/L;if(p>3)continue;const V=Y/(L*L),z=4/3*Math.PI*(p/2)*Math.pow(E/2,2),U=Se(z),m=Pe(V);I.push({majorMm:p,minorMm:E,areaPx:Y,surfaceMm2:V,volMm3:z,attainableVol:U,ey:m});const f=b[g%b.length];e.drawContours(O,A,g,f,1)}const B=.1,J=Math.max(...I.map(g=>g.majorMm)),$=Math.ceil(J/B)+1,G=new Array($).fill(0);for(const g of I){const F=Math.floor(g.majorMm/B);G[F]++}const j=G.indexOf(Math.max(...G));let w=3;for(let g=$-1;g>j;g--)if(G[g]>=3){w=(g+1)*B;break}const T=I.filter(g=>g.majorMm<=w);console.log(`[CV] Outlier filtering: cut-off ${w.toFixed(2)}mm. Removed ${I.length-T.length} particles.`);const Q=Math.round(O.cols*.5),q=Math.round(O.rows*.5),k=new e.Mat;e.resize(O,k,new e.Size(Q,q),0,0,e.INTER_AREA);const X=de(k);return k.delete(),O.delete(),A.delete(),D.delete(),t.delete(),a.delete(),_.delete(),h.delete(),i.delete(),P.delete(),o.delete(),{mode:"grind",particles:T,stageImageData:X}}function Se(n,r,s){const t=Math.pow(.75*n/Math.PI,.3333333333333333);if(t<=.1)return n;const a=4/3*Math.PI*Math.pow(t-.1,3);return Math.max(0,n-a)}function Pe(n){const o=1/n;return o/(.25014+o)*.3}function xe(n,r){const s=n.data,o=n.rows*n.cols*4;for(let t=0;t<o;t+=4)s[t]=Math.min(255,Math.max(0,Math.round(s[t]*r.r))),s[t+1]=Math.min(255,Math.max(0,Math.round(s[t+1]*r.g))),s[t+2]=Math.min(255,Math.max(0,Math.round(s[t+2]*r.b)))}function Ie(n,r,s,o){console.log("[CV] analyzeBeans start");const t=n.clone();ue(t,r),xe(t,s);const a=new e.Mat;e.cvtColor(t,a,e.COLOR_RGBA2GRAY);const _=new e.Mat;e.GaussianBlur(a,_,new e.Size(5,5),0);const h=new e.Mat;e.GaussianBlur(_,h,new e.Size(0,0),40);const i=new e.Mat;e.subtract(h,_,i),e.normalize(i,i,0,255,e.NORM_MINMAX);const u=new e.Mat;e.threshold(i,u,25,255,e.THRESH_BINARY);const P=e.getStructuringElement(e.MORPH_ELLIPSE,new e.Size(3,3));e.morphologyEx(u,u,e.MORPH_CLOSE,P,new e.Point(-1,-1),1),e.morphologyEx(u,u,e.MORPH_OPEN,P,new e.Point(-1,-1),1);const x=Math.floor(2*l.SCALE),A=le(u.rows,u.cols,e.CV_8UC1),D=new e.Point(x,x),R=new e.Point(u.cols-x,u.rows-x);e.rectangle(A,D,R,new e.Scalar(255),-1),e.bitwise_and(u,u,u,A),console.log("[CV] analyzeBeans: findContours");const H=new e.MatVector,L=new e.Mat;e.findContours(u,H,L,e.RETR_EXTERNAL,e.CHAIN_APPROX_SIMPLE);const I=H.size();console.log("[CV] analyzeBeans: contours",I,"bean loop start");const b=[],O=50;for(let w=0;w<I;w++){const T=H.get(w);if(!(e.contourArea(T)<O)&&T.rows>=5){const q=e.fitEllipse(T),k=q.size.width,X=q.size.height,g=Math.max(k,X)/(Math.min(k,X)||1);if(g>3){console.log("[CV] analyzeBeans: filtered contour with aspect ratio",g.toFixed(2));continue}const F=Math.max(k,X)/l.SCALE*o,Y=Math.min(k,X)/l.SCALE*o,c=le(n.rows,n.cols,e.CV_8UC1);e.drawContours(c,H,w,new e.Scalar(255),-1);const M=e.mean(t,c),d=Math.min(255,Math.max(0,M[0])),p=Math.min(255,Math.max(0,M[1])),E=Math.min(255,Math.max(0,M[2])),V=.299*d+.587*p+.114*E;b.push({majorMm:F,minorMm:Y,r:d,g:p,b:E,luma:V}),c.delete()}}console.log("[CV] analyzeBeans done, beans:",b.length);const B=new e.Scalar(0,255,0,255);for(let w=0;w<I;w++){const T=H.get(w);e.contourArea(T)>=O&&T.rows>=5&&e.drawContours(t,H,w,B,4),console.log("[CV] analyzeBeans: contour",w,"area",e.contourArea(T),"x",T.data32F[0],"y",T.data32F[1])}const J=Math.round(t.cols*.5),$=Math.round(t.rows*.5),G=new e.Mat;e.resize(t,G,new e.Size(J,$),0,0,e.INTER_AREA);const j=de(G);return G.delete(),a.delete(),_.delete(),h.delete(),i.delete(),u.delete(),P.delete(),A.delete(),H.delete(),L.delete(),t.delete(),{mode:"bean",beans:b,stageImageData:j}}function ie(n,r){const s=new Uint8Array(256),o=n.map((t,a)=>({x:t,y:r[a]})).sort((t,a)=>t.x-a.x);for(let t=0;t<256;t++)if(t<=o[0].x)s[t]=o[0].y;else if(t>=o[o.length-1].x)s[t]=o[o.length-1].y;else for(let a=0;a<o.length-1;a++)if(t>=o[a].x&&t<=o[a+1].x){const _=o[a+1].x-o[a].x,h=_===0?0:(t-o[a].x)/_;s[t]=Math.round(o[a].y+h*(o[a+1].y-o[a].y));break}return s}function de(n){return{data:new Uint8Array(n.data),width:n.cols,height:n.rows}}function ue(n,r){const s=n.data,o=n.rows*n.cols*4;for(let t=0;t<o;t+=4)s[t]=r.r[s[t]],s[t+1]=r.g[s[t+1]],s[t+2]=r.b[s[t+2]]}})();
